package moa.classifiers.meta;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import com.github.javacliparser.FlagOption;
import com.github.javacliparser.FloatOption;
import com.github.javacliparser.IntOption;
import com.github.javacliparser.MultiChoiceOption;
import com.yahoo.labs.samoa.instances.Instance;

import moa.AbstractMOAObject;
import moa.capabilities.CapabilitiesHandler;
import moa.capabilities.Capability;
import moa.capabilities.ImmutableCapabilities;
import moa.classifiers.AbstractClassifier;
import moa.classifiers.Classifier;
import moa.classifiers.MultiClassClassifier;
import moa.classifiers.core.driftdetection.ChangeDetector;
import moa.classifiers.meta.AdaptiveRandomForest.ARFBaseLearner;
import moa.classifiers.meta.AdaptiveRandomForest.TrainingRunnable;
import moa.classifiers.trees.ARFHoeffdingTree;
import moa.core.DoubleVector;
import moa.core.InstanceExample;
import moa.core.Measurement;
import moa.core.MiscUtils;
import moa.core.Utils;
import moa.evaluation.BasicClassificationPerformanceEvaluator;
import moa.options.ClassOption;

public class ISAdaptiveRandomForest extends AbstractClassifier implements MultiClassClassifier,
CapabilitiesHandler {

	@Override
	public String getPurposeString() {
		return "Adaptive Random Forest algorithm for evolving data streams from Gomes et al.";
	}

	private static final long serialVersionUID = 1L;

	public ClassOption treeLearnerOption = new ClassOption("treeLearner", 'l',
			"Random Forest Tree.", ARFHoeffdingTree.class,
			"ARFHoeffdingTree -e 2000000 -g 50 -c 0.01");

	public IntOption ensembleSizeOption = new IntOption("ensembleSize", 's',
			"The number of trees.", 100, 1, Integer.MAX_VALUE);

	public MultiChoiceOption mFeaturesModeOption = new MultiChoiceOption("mFeaturesMode", 'o', 
			"Defines how m, defined by mFeaturesPerTreeSize, is interpreted. M represents the total number of features.",
			new String[]{"Specified m (integer value)", "sqrt(M)+1", "M-(sqrt(M)+1)",
	"Percentage (M * (m / 100))"},
			new String[]{"SpecifiedM", "SqrtM1", "MSqrtM1", "Percentage"}, 3);

	public IntOption mFeaturesPerTreeSizeOption = new IntOption("mFeaturesPerTreeSize", 'm',
			"Number of features allowed considered for each split. Negative values corresponds to M - m", 60, Integer.MIN_VALUE, Integer.MAX_VALUE);

	public FloatOption lambdaOption = new FloatOption("lambda", 'a',
			"The lambda parameter for bagging.", 6.0, 1.0, Float.MAX_VALUE);

	public IntOption numberOfJobsOption = new IntOption("numberOfJobs", 'j',
			"Total number of concurrent jobs used for processing (-1 = as much as possible, 0 = do not use multithreading)", 1, -1, Integer.MAX_VALUE);

	public ClassOption driftDetectionMethodOption = new ClassOption("driftDetectionMethod", 'x',
			"Change detector for drifts and its parameters", ChangeDetector.class, "ADWINChangeDetector -a 1.0E-3");

	public ClassOption warningDetectionMethodOption = new ClassOption("warningDetectionMethod", 'p',
			"Change detector for warnings (start training bkg learner)", ChangeDetector.class, "ADWINChangeDetector -a 1.0E-2");

	public FlagOption disableWeightedVote = new FlagOption("disableWeightedVote", 'w', 
			"Should use weighted voting?");

	public FlagOption disableDriftDetectionOption = new FlagOption("disableDriftDetection", 'u',
			"Should use drift detection? If disabled then bkg learner is also disabled");

	public FlagOption disableBackgroundLearnerOption = new FlagOption("disableBackgroundLearner", 'q', 
			"Should use bkg learner? If disabled then reset tree immediately.");

	public IntOption seedForInstanceSelection = new IntOption("seedForInstanceSelection", 'e',
            "Random seed used to select a training instance.", 100, 0, Integer.MAX_VALUE);
	
	
	public IntOption globalOrLocal = new IntOption("globalOrLocal", 'c',
            "Instance selection global or local (global = 1, local = 2).", 1, 1, 2);
	
	public FloatOption controlFactorIS = new FloatOption(
			"ControlFactorIS",
			'i',
			"Control factor for instance selection (1 = Correctly classified instances are not used for training)",
			0.0000001, 0.0, 1.0);
	
	protected static final int FEATURES_M = 0;
	protected static final int FEATURES_SQRT = 1;
	protected static final int FEATURES_SQRT_INV = 2;
	protected static final int FEATURES_PERCENT = 3;

	protected static final int SINGLE_THREAD = 0;

	protected ARFBaseLearner[] ensemble;
	protected long instancesSeen;
	protected int subspaceSize;
	protected BasicClassificationPerformanceEvaluator evaluator;

	private ExecutorService executor;

	protected Random randomInstanceSelection;
	
	
	@Override
	public void resetLearningImpl() {
		// Reset attributes
		this.ensemble = null;
		this.subspaceSize = 0;
		this.instancesSeen = 0;
		this.evaluator = new BasicClassificationPerformanceEvaluator();

		// Multi-threading
		int numberOfJobs;
		if(this.numberOfJobsOption.getValue() == -1) 
			numberOfJobs = Runtime.getRuntime().availableProcessors();
		else 
			numberOfJobs = this.numberOfJobsOption.getValue();
		// SINGLE_THREAD and requesting for only 1 thread are equivalent. 
		// this.executor will be null and not used...
		if(numberOfJobs != AdaptiveRandomForest.SINGLE_THREAD && numberOfJobs != 1)
			this.executor = Executors.newFixedThreadPool(numberOfJobs);
	}

	@Override
	public void trainOnInstanceImpl(Instance instance) {
		++this.instancesSeen;
		if(this.ensemble == null) 
			initEnsemble(instance);
		
		//global 
		boolean usedToTrain = true;
		double delta = this.controlFactorIS.getValue();
    	
		int trueClass = (int) instance.classValue();
		if (this.globalOrLocal.getValue() == 1) {
			DoubleVector vote_global = new DoubleVector(this.getVotesForInstance(instance));
			int predictedClass = Utils.maxIndex(vote_global.getArrayRef());
			
			if (delta == 1) { //use only misclassified 
	    		usedToTrain = (trueClass!=predictedClass);
	    	}
	    	else if (trueClass==predictedClass) {
				double	random = this.randomInstanceSelection.nextDouble();
				usedToTrain = (random>delta);
			}
		}

    	if (usedToTrain) {
			Collection<TrainingRunnable> trainers = new ArrayList<TrainingRunnable>();
			for (int i = 0 ; i < this.ensemble.length ; i++) {
				DoubleVector vote = new DoubleVector(this.ensemble[i].getVotesForInstance(instance));
				InstanceExample example = new InstanceExample(instance);
				this.ensemble[i].evaluator.addResult(example, vote.getArrayRef());
				
				//local
				if (this.globalOrLocal.getValue() == 2) {
					int predictedClassLocal = Utils.maxIndex(vote.getArrayRef());
					usedToTrain = true;
					if (delta == 1) { //use only misclassified 
			    		usedToTrain = (trueClass!=predictedClassLocal);
			    	}
			    	else if (trueClass==predictedClassLocal) {
						double	random = this.randomInstanceSelection.nextDouble();
						usedToTrain = (random>delta);
					}
				}
				
				if (usedToTrain) {
					int k = MiscUtils.poisson(this.lambdaOption.getValue(), this.classifierRandom);
					if (k > 0) {
						if(this.executor != null) {
							TrainingRunnable trainer = new TrainingRunnable(this.ensemble[i], 
									instance, k, this.instancesSeen);
							trainers.add(trainer);
						}
						else { // SINGLE_THREAD is in-place... 
							this.ensemble[i].trainOnInstance(instance, k, this.instancesSeen);
						}
					}
				}
			}
			
			if(this.executor != null) {
				try {
					this.executor.invokeAll(trainers);
				} catch (InterruptedException ex) {
					throw new RuntimeException("Could not call invokeAll() on training threads.");
				}
			}
		}
		
	}

	@Override
	public double[] getVotesForInstance(Instance instance) {
		Instance testInstance = instance.copy();
		if(this.ensemble == null) 
			initEnsemble(testInstance);
		DoubleVector combinedVote = new DoubleVector();

		for(int i = 0 ; i < this.ensemble.length ; ++i) {
			DoubleVector vote = new DoubleVector(this.ensemble[i].getVotesForInstance(testInstance));
			if (vote.sumOfValues() > 0.0) {
				vote.normalize();
				double acc = this.ensemble[i].evaluator.getPerformanceMeasurements()[1].getValue();
				if(! this.disableWeightedVote.isSet() && acc > 0.0) {                        
					for(int v = 0 ; v < vote.numValues() ; ++v) {
						vote.setValue(v, vote.getValue(v) * acc);
					}
				}
				combinedVote.addValues(vote);
			}
		}
		return combinedVote.getArrayRef();
	}

	@Override
	public boolean isRandomizable() {
		return true;
	}

	@Override
	public void getModelDescription(StringBuilder arg0, int arg1) {
	}

	@Override
	protected Measurement[] getModelMeasurementsImpl() {
		limpaThreads();
		
		double sum = 0;
		 for(int i = 0 ; i < this.ensemble.length ; ++i) {
			 sum += this.ensemble[i].countInstanceTrain;			 
		 }
		 double media = sum/this.ensemble.length;
		 System.out.println("Media="+media);
		 return new Measurement[]{
               new Measurement(
              		 "Avg. of instances for training",
               media)};
	
		//return null;
	}

	@Override
	public Measurement[] getModelMeasurements() {
		Measurement[] measurements = super.getModelMeasurements();
		limpaThreads();
		return measurements;
	}

	public void limpaThreads() {
		// tries to solve the hanging threads issue
		if(this.executor != null) {
			this.executor.shutdownNow();
			this.executor = null;
		}
	}

	protected void initEnsemble(Instance instance) {
		// Init the ensemble.
		int ensembleSize = this.ensembleSizeOption.getValue();
		this.ensemble = new ARFBaseLearner[ensembleSize];
		
		this.randomInstanceSelection = new Random(this.seedForInstanceSelection.getValue());
		

		// TODO: this should be an option with default = BasicClassificationPerformanceEvaluator
		//BasicClassificationPerformanceEvaluator classificationEvaluator = (BasicClassificationPerformanceEvaluator) getPreparedClassOption(this.evaluatorOption);
		BasicClassificationPerformanceEvaluator classificationEvaluator = new BasicClassificationPerformanceEvaluator();

		this.subspaceSize = this.mFeaturesPerTreeSizeOption.getValue();

		// The size of m depends on:
		// 1) mFeaturesPerTreeSizeOption
		// 2) mFeaturesModeOption
		int n = instance.numAttributes()-1; // Ignore class label ( -1 )

		switch(this.mFeaturesModeOption.getChosenIndex()) {
		case AdaptiveRandomForest.FEATURES_SQRT:
			this.subspaceSize = (int) Math.round(Math.sqrt(n)) + 1;
			break;
		case AdaptiveRandomForest.FEATURES_SQRT_INV:
			this.subspaceSize = n - (int) Math.round(Math.sqrt(n) + 1);
			break;
		case AdaptiveRandomForest.FEATURES_PERCENT:
			// If subspaceSize is negative, then first find out the actual percent, i.e., 100% - m.
			double percent = this.subspaceSize < 0 ? (100 + this.subspaceSize)/100.0 : this.subspaceSize / 100.0;
			this.subspaceSize = (int) Math.round(n * percent);
			break;
		}
		// Notice that if the selected mFeaturesModeOption was 
		//  AdaptiveRandomForest.FEATURES_M then nothing is performed in the
		//  previous switch-case, still it is necessary to check (and adjusted) 
		//  for when a negative value was used. 

		// m is negative, use size(features) + -m
		if(this.subspaceSize < 0)
			this.subspaceSize = n + this.subspaceSize;
		// Other sanity checks to avoid runtime errors. 
		//  m <= 0 (m can be negative if this.subspace was negative and 
		//  abs(m) > n), then use m = 1
		if(this.subspaceSize <= 0)
			this.subspaceSize = 1;
		// m > n, then it should use n
		if(this.subspaceSize > n)
			this.subspaceSize = n;

		ARFHoeffdingTree treeLearner = (ARFHoeffdingTree) getPreparedClassOption(this.treeLearnerOption);
		treeLearner.resetLearning();

		for(int i = 0 ; i < ensembleSize ; ++i) {
			treeLearner.subspaceSizeOption.setValue(this.subspaceSize);
			this.ensemble[i] = new ARFBaseLearner(
					i, 
					(ARFHoeffdingTree) treeLearner.copy(), 
					(BasicClassificationPerformanceEvaluator) classificationEvaluator.copy(), 
					this.instancesSeen, 
					! this.disableBackgroundLearnerOption.isSet(),
					! this.disableDriftDetectionOption.isSet(), 
					driftDetectionMethodOption,
					warningDetectionMethodOption,
					false);
		}
	}

	@Override
	public ImmutableCapabilities defineImmutableCapabilities() {
		if (this.getClass() == ISAdaptiveRandomForest.class)
			return new ImmutableCapabilities(Capability.VIEW_STANDARD, Capability.VIEW_LITE);
		else
			return new ImmutableCapabilities(Capability.VIEW_STANDARD);
	}

	@Override
	public Classifier[] getSublearners() {
		/* Extracts the reference to the ARFHoeffdingTree object from within the ensemble of ARFBaseLearner's */
		Classifier[] forest = new Classifier[this.ensemble.length];
		for(int i = 0 ; i < forest.length ; ++i)
			forest[i] = this.ensemble[i].classifier;
		return forest;

	}

	/**
	 * Inner class that represents a single tree member of the forest. 
	 * It contains some analysis information, such as the numberOfDriftsDetected, 
	 */
	protected final class ARFBaseLearner extends AbstractMOAObject {
		public int indexOriginal;
		public long createdOn;
		public long lastDriftOn;
		public long lastWarningOn;
		public ARFHoeffdingTree classifier;
		public boolean isBackgroundLearner;

		// The drift and warning object parameters. 
		protected ClassOption driftOption;
		protected ClassOption warningOption;

		// Drift and warning detection
		protected ChangeDetector driftDetectionMethod;
		protected ChangeDetector warningDetectionMethod;

		public boolean useBkgLearner;
		public boolean useDriftDetector;

		// Bkg learner
		protected ARFBaseLearner bkgLearner;
		// Statistics
		public BasicClassificationPerformanceEvaluator evaluator;
		protected int numberOfDriftsDetected;
		protected int numberOfWarningsDetected;

		protected int countInstanceTrain;

		
		private void init(int indexOriginal, ARFHoeffdingTree instantiatedClassifier, BasicClassificationPerformanceEvaluator evaluatorInstantiated, 
				long instancesSeen, boolean useBkgLearner, boolean useDriftDetector, ClassOption driftOption, ClassOption warningOption, boolean isBackgroundLearner) {
			this.indexOriginal = indexOriginal;
			this.createdOn = instancesSeen;
			this.lastDriftOn = 0;
			this.lastWarningOn = 0;

			this.classifier = instantiatedClassifier;
			this.evaluator = evaluatorInstantiated;
			this.useBkgLearner = useBkgLearner;
			this.useDriftDetector = useDriftDetector;

			this.numberOfDriftsDetected = 0;
			this.numberOfWarningsDetected = 0;
			this.isBackgroundLearner = isBackgroundLearner;

			if(this.useDriftDetector) {
				this.driftOption = driftOption;
				this.driftDetectionMethod = ((ChangeDetector) getPreparedClassOption(this.driftOption)).copy();
			}

			// Init Drift Detector for Warning detection. 
			if(this.useBkgLearner) {
				this.warningOption = warningOption;
				this.warningDetectionMethod = ((ChangeDetector) getPreparedClassOption(this.warningOption)).copy();
			}
			
			this.countInstanceTrain = 0;

		}

		public ARFBaseLearner(int indexOriginal, ARFHoeffdingTree instantiatedClassifier, BasicClassificationPerformanceEvaluator evaluatorInstantiated, 
				long instancesSeen, boolean useBkgLearner, boolean useDriftDetector, ClassOption driftOption, ClassOption warningOption, boolean isBackgroundLearner) {
			init(indexOriginal, instantiatedClassifier, evaluatorInstantiated, instancesSeen, useBkgLearner, useDriftDetector, driftOption, warningOption, isBackgroundLearner);
		}

		public void reset() {
			if(this.useBkgLearner && this.bkgLearner != null) {
				this.classifier = this.bkgLearner.classifier;

				this.driftDetectionMethod = this.bkgLearner.driftDetectionMethod;
				this.warningDetectionMethod = this.bkgLearner.warningDetectionMethod;

				this.evaluator = this.bkgLearner.evaluator;
				this.createdOn = this.bkgLearner.createdOn;
				this.bkgLearner = null;
			}
			else {
				this.classifier.resetLearning();
				this.createdOn = instancesSeen;
				this.driftDetectionMethod = ((ChangeDetector) getPreparedClassOption(this.driftOption)).copy();
			}
			this.evaluator.reset();
		}

		public void trainOnInstance(Instance instance, double weight, long instancesSeen) {
			Instance weightedInstance = instance.copy();
			weightedInstance.setWeight(instance.weight() * weight);
			this.classifier.trainOnInstance(weightedInstance);
			this.countInstanceTrain++;
			
			if(this.bkgLearner != null)
				this.bkgLearner.classifier.trainOnInstance(instance);

			// Should it use a drift detector? Also, is it a backgroundLearner? If so, then do not "incept" another one. 
			if(this.useDriftDetector && !this.isBackgroundLearner) {
				boolean correctlyClassifies = this.classifier.correctlyClassifies(instance);
				// Check for warning only if useBkgLearner is active
				if(this.useBkgLearner) {
					// Update the warning detection method
					this.warningDetectionMethod.input(correctlyClassifies ? 0 : 1);
					// Check if there was a change
					if(this.warningDetectionMethod.getChange()) {
						this.lastWarningOn = instancesSeen;
						this.numberOfWarningsDetected++;
						// Create a new bkgTree classifier
						ARFHoeffdingTree bkgClassifier = (ARFHoeffdingTree) this.classifier.copy();
						bkgClassifier.resetLearning();

						// Resets the evaluator
						BasicClassificationPerformanceEvaluator bkgEvaluator = (BasicClassificationPerformanceEvaluator) this.evaluator.copy();
						bkgEvaluator.reset();

						// Create a new bkgLearner object
						this.bkgLearner = new ARFBaseLearner(indexOriginal, bkgClassifier, bkgEvaluator, instancesSeen, 
								this.useBkgLearner, this.useDriftDetector, this.driftOption, this.warningOption, true);

						// Update the warning detection object for the current object 
						// (this effectively resets changes made to the object while it was still a bkg learner). 
						this.warningDetectionMethod = ((ChangeDetector) getPreparedClassOption(this.warningOption)).copy();
					}
				}

				/*********** drift detection ***********/
				// Update the DRIFT detection method
				this.driftDetectionMethod.input(correctlyClassifies ? 0 : 1);
				// Check if there was a change
				if(this.driftDetectionMethod.getChange()) {
					this.lastDriftOn = instancesSeen;
					this.numberOfDriftsDetected++;
					this.reset();
				}
			}
		}

		public double[] getVotesForInstance(Instance instance) {
			DoubleVector vote = new DoubleVector(this.classifier.getVotesForInstance(instance));
			return vote.getArrayRef();
		}

		@Override
		public void getDescription(StringBuilder sb, int indent) {
		}
	}

	/***
	 * Inner class to assist with the multi-thread execution. 
	 */
	protected class TrainingRunnable implements Runnable, Callable<Integer> {
		final private ARFBaseLearner learner;
		final private Instance instance;
		final private double weight;
		final private long instancesSeen;

		public TrainingRunnable(ARFBaseLearner learner, Instance instance, 
				double weight, long instancesSeen) {
			this.learner = learner;
			this.instance = instance;
			this.weight = weight;
			this.instancesSeen = instancesSeen;
		}

		@Override
		public void run() {
			learner.trainOnInstance(this.instance, this.weight, this.instancesSeen);
		}

		@Override
		public Integer call() {
			run();
			return 0;
		}
	}
}
